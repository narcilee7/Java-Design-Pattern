# Java 设计模式

## 单例模式

分为：
1. 懒汉式
2. 饿汉式

饿汉式：线程安全，但是生命周期与类加载时一致。
懒汉式：线程不安全，类加载时不创建对象，创建对象时才进行同步，所以需要加锁。

总结：实际上我们大多时候使用饿汉式，因为这个单例迟早要被实例化、占用内存，延迟懒加载的意义不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率。

**越简单的包容性越强，越复杂的反而越容易出错**

## 原型模式

原型模式的目的是从原型实例克隆出新的实例，对于那些有非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。

实现方式即：implements Cloneable接口，重写clone方法。这种原型模式的拷贝属于**浅拷贝**

## 工厂模式

## 抽象工厂

抽象工厂是对工厂的抽象化，而不只是制造方法。

为了满足不同用户对于产品的多样化需求，工厂不会仅局限于一类产品，但是系统如果按工厂方法那样为每种产品都增加一个新工厂又会造成工厂泛滥。
所以，为了调和这种矛盾，抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。
**抽象工厂是建立在制造复杂产品体系需求基础之上的一种设计模式，在某种意义上，我们可以将抽象工厂模式理解为工厂方法模式的高度集群化升级版。**

与工厂方法模式不同，抽象工厂模式能够应对更加复杂的产品族系，它更类似于一种对“工业制造标准”的制定与推行，各工厂实现都遵循此标准来进行生产活动，**以工厂类划分产品族，以制造方法划分产品系列**，达到无限扩展产品的目的。