# Java 设计模式

## 创建者模式

### 单例模式

分为：
1. 懒汉式
2. 饿汉式

饿汉式：线程安全，但是生命周期与类加载时一致。
懒汉式：线程不安全，类加载时不创建对象，创建对象时才进行同步，所以需要加锁。

总结：实际上我们大多时候使用饿汉式，因为这个单例迟早要被实例化、占用内存，延迟懒加载的意义不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率。

**越简单的包容性越强，越复杂的反而越容易出错**

### 原型模式

原型模式的目的是从原型实例克隆出新的实例，对于那些有非常复杂的初始化过程的对象或者是需要耗费大量资源的情况，原型模式是更好的选择。

实现方式即：implements Cloneable接口，重写clone方法。这种原型模式的拷贝属于**浅拷贝**

### 工厂模式

### 抽象工厂

抽象工厂是对工厂的抽象化，而不只是制造方法。

为了满足不同用户对于产品的多样化需求，工厂不会仅局限于一类产品，但是系统如果按工厂方法那样为每种产品都增加一个新工厂又会造成工厂泛滥。
所以，为了调和这种矛盾，抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。
**抽象工厂是建立在制造复杂产品体系需求基础之上的一种设计模式，在某种意义上，我们可以将抽象工厂模式理解为工厂方法模式的高度集群化升级版。**

与工厂方法模式不同，抽象工厂模式能够应对更加复杂的产品族系，它更类似于一种对“工业制造标准”的制定与推行，各工厂实现都遵循此标准来进行生产活动，**以工厂类划分产品族，以制造方法划分产品系列**，达到无限扩展产品的目的。

### 建造者

建造者模式(Builder)所构建的对象一定是庞大而复杂的，并且一定是按照既定的制造工序将组件组装起来的，例如计算机、汽车、建筑物等。我们通常将负责构建这些大型对象的工程师称为建造者。
建造者模式又称为生成器模式，**主要用于对复杂对象的构建、初始化，它可以将多个简单的组件对象按顺序一步步组装起来，最终构建成一个复杂的成品对象**。
与工厂系列模式不同的是，**建造者模式的主要目的在于把烦琐的构建过程从不同对象中抽离出来，使其脱离并独立于产品类与工厂类，最终实现用同一套标准的制造工序能够产出不同的产品**。

## 结构型模式

### 外观模式

Facade可能是最简单的结构型设计模式，它能够使得多个不同的子系统接口封装起来，并对外提供统一的高层接口，使得复杂的子系统变得更加易用。

### 组合模式

组合模式(Composite)是针对由多个节点对象（部分）组成的树形结构的对象（整体）而发展出的一种结构型设计模式，它能够使客户端在操作整体对象或者其下的每个节点对象时做出统一的响应，保证树形结构对象使用方法的一致性，使客户端不必关注对象的整体或部分，最终达到对象复杂的层次结构与客户端解耦的目的。